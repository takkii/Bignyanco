import { BaseApi } from './Base';
export interface BufferSetLines {
    start?: number;
    end?: number;
    strictIndexing?: boolean;
}
export interface BufferHighlight {
    hlGroup?: string;
    line?: number;
    colStart?: number;
    colEnd?: number;
    srcId?: number;
}
export interface BufferClearHighlight {
    srcId?: number;
    lineStart?: number;
    lineEnd?: number;
}
export declare const DETACH: unique symbol;
export declare const ATTACH: unique symbol;
export declare class Buffer extends BaseApi {
    prefix: string;
    private isAttached;
    /**
     * Attach to buffer to listen to buffer events
     * @param sendBuffer Set to true if the initial notification should contain
     *        the whole buffer. If so, the first notification will be a
     *        `nvim_buf_lines_event`. Otherwise, the first notification will be
     *        a `nvim_buf_changedtick_event`
     */
    [ATTACH]: (sendBuffer?: boolean, options?: {}) => Promise<any>;
    /**
     * Detach from buffer to stop listening to buffer events
     */
    [DETACH]: () => Promise<any>;
    /**
     * Get the bufnr of Buffer
     */
    readonly id: number;
    /** Total number of lines in buffer */
    readonly length: Promise<number>;
    /** Get lines in buffer */
    readonly lines: Promise<Array<string>>;
    /** Gets a changed tick of a buffer */
    readonly changedtick: Promise<number>;
    readonly commands: Promise<Object>;
    getCommands(options?: {}): Promise<Object>;
    /** Get specific lines of buffer */
    getLines({ start, end, strictIndexing }?: {
        start: number;
        end: number;
        strictIndexing: boolean;
    }): Promise<Array<string>>;
    /** Set lines of buffer given indeces */
    setLines(_lines: string | string[], { start: _start, end: _end, strictIndexing }?: BufferSetLines): Promise<any>;
    /** Insert lines at `start` index */
    insert(lines: Array<string> | string, start: number): Promise<any>;
    /** Replace lines starting at `start` index */
    replace(_lines: Array<string> | string, start: number): Promise<any>;
    /** Remove lines at index */
    remove(start: number, end: number, strictIndexing: boolean): Promise<any>;
    /** Append a string or list of lines to end of buffer */
    append(lines: Array<string> | string): Promise<any>;
    /** Get buffer name */
    /** Set current buffer name */
    name: string | Promise<string>;
    /** Is current buffer valid */
    readonly valid: Promise<boolean>;
    /** Get mark position given mark name */
    mark(name: string): Promise<[number, number]>;
    /** Gets keymap */
    getKeymap(mode: string): Promise<Array<object>>;
    /**
      Adds a highlight to buffer.
  
      This can be used for plugins which dynamically generate
      highlights to a buffer (like a semantic highlighter or
      linter). The function adds a single highlight to a buffer.
      Unlike matchaddpos() highlights follow changes to line
      numbering (as lines are inserted/removed above the highlighted
      line), like signs and marks do.
  
      "src_id" is useful for batch deletion/updating of a set of
      highlights. When called with src_id = 0, an unique source id
      is generated and returned. Succesive calls can pass in it as
      "src_id" to add new highlights to the same source group. All
      highlights in the same group can then be cleared with
      nvim_buf_clear_highlight. If the highlight never will be
      manually deleted pass in -1 for "src_id".
  
      If "hl_group" is the empty string no highlight is added, but a
      new src_id is still returned. This is useful for an external
      plugin to synchrounously request an unique src_id at
      initialization, and later asynchronously add and clear
      highlights in response to buffer changes. */
    addHighlight({ hlGroup: _hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId, }: BufferHighlight): Promise<number>;
    /** Clears highlights from a given source group and a range of
    lines
  
    To clear a source group in the entire buffer, pass in 1 and -1
    to lineStart and lineEnd respectively. */
    clearHighlight(args?: BufferClearHighlight): Promise<any>;
    /**
     * Listens to buffer for events
     */
    listen(eventName: string, cb: Function): Function;
    unlisten(eventName: string, cb: Function): void;
}
export interface AsyncBuffer extends Buffer, Promise<Buffer> {
}
