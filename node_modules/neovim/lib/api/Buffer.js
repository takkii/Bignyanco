"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _a, _b;
const Base_1 = require("./Base");
const types_1 = require("./types");
exports.DETACH = Symbol('detachBuffer');
exports.ATTACH = Symbol('attachBuffer');
class Buffer extends Base_1.BaseApi {
    constructor() {
        super(...arguments);
        this.prefix = types_1.Metadata[types_1.ExtType.Buffer].prefix;
        this.isAttached = false;
        /**
         * Attach to buffer to listen to buffer events
         * @param sendBuffer Set to true if the initial notification should contain
         *        the whole buffer. If so, the first notification will be a
         *        `nvim_buf_lines_event`. Otherwise, the first notification will be
         *        a `nvim_buf_changedtick_event`
         */
        this[_a] = (sendBuffer = false, options = {}) => this.request(`${this.prefix}attach`, [this, sendBuffer, options]);
        /**
         * Detach from buffer to stop listening to buffer events
         */
        this[_b] = () => this.request(`${this.prefix}detach`, [this]);
    }
    /**
     * Get the bufnr of Buffer
     */
    get id() {
        return this.data;
    }
    /** Total number of lines in buffer */
    get length() {
        return this.request(`${this.prefix}line_count`, [this]);
    }
    /** Get lines in buffer */
    get lines() {
        return this.getLines();
    }
    /** Gets a changed tick of a buffer */
    get changedtick() {
        return this.request(`${this.prefix}get_changedtick`, [this]);
    }
    get commands() {
        return this.getCommands();
    }
    getCommands(options = {}) {
        return this.request(`${this.prefix}get_commands`, [this, options]);
    }
    /** Get specific lines of buffer */
    getLines({ start, end, strictIndexing } = { start: 0, end: -1, strictIndexing: true }) {
        const indexing = typeof strictIndexing === 'undefined' ? true : strictIndexing;
        return this.request(`${this.prefix}get_lines`, [
            this,
            start,
            end,
            indexing,
        ]);
    }
    /** Set lines of buffer given indeces */
    setLines(_lines, { start: _start, end: _end, strictIndexing } = {
        strictIndexing: true,
    }) {
        // TODO: Error checking
        // if (typeof start === 'undefined' || typeof end === 'undefined') {
        // }
        const indexing = typeof strictIndexing === 'undefined' ? true : strictIndexing;
        const lines = typeof _lines === 'string' ? [_lines] : _lines;
        const end = typeof _end !== 'undefined' ? _end : _start + 1;
        return this.request(`${this.prefix}set_lines`, [
            this,
            _start,
            end,
            indexing,
            lines,
        ]);
    }
    /** Insert lines at `start` index */
    insert(lines, start) {
        return this.setLines(lines, {
            start,
            end: start,
            strictIndexing: true,
        });
    }
    /** Replace lines starting at `start` index */
    replace(_lines, start) {
        const lines = typeof _lines === 'string' ? [_lines] : _lines;
        return this.setLines(lines, {
            start,
            end: start + lines.length + 1,
            strictIndexing: false,
        });
    }
    /** Remove lines at index */
    remove(start, end, strictIndexing) {
        return this.setLines([], { start, end, strictIndexing });
    }
    /** Append a string or list of lines to end of buffer */
    append(lines) {
        return this.setLines(lines, {
            start: -1,
            end: -1,
            strictIndexing: false,
        });
    }
    /** Get buffer name */
    get name() {
        return this.request(`${this.prefix}get_name`, [this]);
    }
    /** Set current buffer name */
    set name(value) {
        this.request(`${this.prefix}set_name`, [this, value]);
    }
    /** Is current buffer valid */
    get valid() {
        return this.request(`${this.prefix}is_valid`, [this]);
    }
    /** Get mark position given mark name */
    mark(name) {
        return this.request(`${this.prefix}get_mark`, [this, name]);
    }
    // range(start, end) {
    // """Return a `Range` object, which represents part of the Buffer."""
    // return Range(this, start, end)
    // }
    /** Gets keymap */
    getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [this, mode]);
    }
    /**
      Adds a highlight to buffer.
  
      This can be used for plugins which dynamically generate
      highlights to a buffer (like a semantic highlighter or
      linter). The function adds a single highlight to a buffer.
      Unlike matchaddpos() highlights follow changes to line
      numbering (as lines are inserted/removed above the highlighted
      line), like signs and marks do.
  
      "src_id" is useful for batch deletion/updating of a set of
      highlights. When called with src_id = 0, an unique source id
      is generated and returned. Succesive calls can pass in it as
      "src_id" to add new highlights to the same source group. All
      highlights in the same group can then be cleared with
      nvim_buf_clear_highlight. If the highlight never will be
      manually deleted pass in -1 for "src_id".
  
      If "hl_group" is the empty string no highlight is added, but a
      new src_id is still returned. This is useful for an external
      plugin to synchrounously request an unique src_id at
      initialization, and later asynchronously add and clear
      highlights in response to buffer changes. */
    addHighlight({ hlGroup: _hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId, }) {
        const hlGroup = typeof _hlGroup !== 'undefined' ? _hlGroup : '';
        const colEnd = typeof _end !== 'undefined' ? _end : -1;
        const colStart = typeof _start !== 'undefined' ? _start : -0;
        const srcId = typeof _srcId !== 'undefined' ? _srcId : -1;
        return this.request(`${this.prefix}add_highlight`, [
            this,
            srcId,
            hlGroup,
            line,
            colStart,
            colEnd,
        ]);
    }
    /** Clears highlights from a given source group and a range of
    lines
  
    To clear a source group in the entire buffer, pass in 1 and -1
    to lineStart and lineEnd respectively. */
    clearHighlight(args = {}) {
        const defaults = {
            srcId: -1,
            lineStart: 0,
            lineEnd: -1,
        };
        const { srcId, lineStart, lineEnd } = Object.assign({}, defaults, args);
        return this.request(`${this.prefix}clear_highlight`, [
            this,
            srcId,
            lineStart,
            lineEnd,
        ]);
    }
    /**
     * Listens to buffer for events
     */
    listen(eventName, cb) {
        if (!this.isAttached) {
            this[exports.ATTACH]();
            this.isAttached = true;
        }
        this.client.attachBuffer(this, eventName, cb);
        return () => {
            this.unlisten(eventName, cb);
        };
    }
    unlisten(eventName, cb) {
        const shouldDetach = this.client.detachBuffer(this, eventName, cb);
        if (!shouldDetach)
            return;
        this.isAttached = false;
        this[exports.DETACH]();
    }
}
_a = exports.ATTACH, _b = exports.DETACH;
exports.Buffer = Buffer;
