"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-env jest */
const cp = require("child_process");
// eslint-disable-next-line import/no-extraneous-dependencies
const which = require("which");
const attach_1 = require("../attach");
try {
    which.sync('nvim');
}
catch (e) {
    // eslint-disable-next-line no-console
    console.error('A Neovim installation is required to run the tests', '(see https://github.com/neovim/neovim/wiki/Installing)');
    process.exit(1);
}
describe.only('Buffer API', () => {
    let proc;
    let nvim;
    beforeAll((done) => __awaiter(this, void 0, void 0, function* () {
        proc = cp.spawn('nvim', ['-u', 'NONE', '-N', '--embed', '-c', 'set noswapfile', 'test.js'], {
            cwd: __dirname,
        });
        nvim = yield attach_1.attach({ proc });
        done();
    }));
    afterAll(() => {
        nvim.quit();
        if (proc) {
            proc.disconnect();
        }
    });
    beforeEach(() => { });
    it('gets the current buffer', () => __awaiter(this, void 0, void 0, function* () {
        const buffer = yield nvim.buffer;
        expect(buffer).toBeInstanceOf(nvim.Buffer);
    }));
    describe('Normal API calls', () => {
        let buffer;
        beforeEach(() => __awaiter(this, void 0, void 0, function* () {
            buffer = yield nvim.buffer;
        }));
        it('gets changedtick of buffer', () => __awaiter(this, void 0, void 0, function* () {
            const initial = yield buffer.changedtick;
            // insert a line
            buffer.append('hi');
            expect(yield buffer.changedtick).toBe(initial + 1);
            // clear buffer
            buffer.remove(0, -1, false);
            expect(yield buffer.changedtick).toBe(initial + 2);
        }));
        it('gets the current buffer name', () => __awaiter(this, void 0, void 0, function* () {
            const name = yield buffer.name;
            expect(name).toMatch('test.js');
        }));
        it('is a valid buffer', () => __awaiter(this, void 0, void 0, function* () {
            expect(yield buffer.valid).toBe(true);
        }));
        it('sets current buffer name to "foo.js"', () => __awaiter(this, void 0, void 0, function* () {
            buffer.name = 'foo.js';
            expect(yield buffer.name).toMatch('foo.js');
            buffer.name = 'test.js';
            expect(yield buffer.name).toMatch('test.js');
        }));
        it('can replace first line of buffer with a string', () => __awaiter(this, void 0, void 0, function* () {
            buffer.replace('test', 0);
            expect(yield buffer.lines).toEqual(['test']);
        }));
        it('can insert lines at beginning of buffer', () => __awaiter(this, void 0, void 0, function* () {
            buffer.insert(['test', 'foo'], 0);
            expect(yield buffer.lines).toEqual(['test', 'foo', 'test']);
        }));
        it('can replace buffer starting at line 1', () => __awaiter(this, void 0, void 0, function* () {
            buffer.replace(['bar', 'bar', 'bar'], 1);
            expect(yield buffer.lines).toEqual(['test', 'bar', 'bar', 'bar']);
        }));
        it('inserts line at index 2', () => __awaiter(this, void 0, void 0, function* () {
            buffer.insert(['foo'], 2);
            expect(yield buffer.lines).toEqual(['test', 'bar', 'foo', 'bar', 'bar']);
        }));
        it('removes last 2 lines', () => __awaiter(this, void 0, void 0, function* () {
            buffer.remove(-3, -1);
            expect(yield buffer.lines).toEqual(['test', 'bar', 'foo']);
        }));
        it('append lines to end of buffer', () => __awaiter(this, void 0, void 0, function* () {
            buffer.append(['test', 'test']);
            expect(yield buffer.lines).toEqual([
                'test',
                'bar',
                'foo',
                'test',
                'test',
            ]);
        }));
        it('can clear the buffer', () => __awaiter(this, void 0, void 0, function* () {
            buffer.remove(0, -1);
            // One empty line
            expect(yield buffer.length).toEqual(1);
            expect(yield buffer.lines).toEqual(['']);
        }));
        it('changes buffer options', () => __awaiter(this, void 0, void 0, function* () {
            const initial = yield buffer.getOption('copyindent');
            buffer.setOption('copyindent', true);
            expect(yield buffer.getOption('copyindent')).toBe(true);
            buffer.setOption('copyindent', false);
            expect(yield buffer.getOption('copyindent')).toBe(false);
            // Restore option
            buffer.setOption('copyindent', initial);
            expect(yield buffer.getOption('copyindent')).toBe(initial);
        }));
        it('returns null if variable is not found', () => __awaiter(this, void 0, void 0, function* () {
            const test = yield buffer.getVar('test');
            expect(test).toBe(null);
        }));
        it('can set a b: variable to an object', () => __awaiter(this, void 0, void 0, function* () {
            buffer.setVar('test', { foo: 'testValue' });
            expect(yield buffer.getVar('test')).toEqual({ foo: 'testValue' });
            expect(yield nvim.eval('b:test')).toEqual({ foo: 'testValue' });
        }));
        it('can delete a b: variable', () => __awaiter(this, void 0, void 0, function* () {
            buffer.deleteVar('test');
            expect(yield nvim.eval('exists("b:test")')).toBe(0);
            expect(yield buffer.getVar('test')).toBe(null);
        }));
        it('can get list of commands', () => __awaiter(this, void 0, void 0, function* () {
            expect(yield nvim.buffer.commands).toEqual({});
        }));
        // TODO: How do we run integration tests for add/clear highlights? and get mark
    });
    describe('Chainable API calls', () => {
        it('gets the current buffer name using api chaining', (done) => __awaiter(this, void 0, void 0, function* () {
            expect(yield nvim.buffer.name).toMatch('test.js');
            nvim.buffer.name.then(name => {
                expect(name).toMatch('test.js');
                done();
            });
        }));
        it('can chain calls from Base class i.e. getOption', () => __awaiter(this, void 0, void 0, function* () {
            const initial = yield nvim.buffer.getOption('copyindent');
            nvim.buffer.setOption('copyindent', true);
            expect(yield nvim.buffer.getOption('copyindent')).toBe(true);
            nvim.buffer.setOption('copyindent', false);
            expect(yield nvim.buffer.getOption('copyindent')).toBe(false);
            // Restore option
            nvim.buffer.setOption('copyindent', initial);
            expect(yield nvim.buffer.getOption('copyindent')).toBe(initial);
        }));
        it('sets current buffer name to "bar.js" using api chaining', () => __awaiter(this, void 0, void 0, function* () {
            nvim.buffer.name = 'bar.js';
            expect(yield nvim.buffer.name).toMatch('bar.js');
            nvim.buffer.name = 'test.js';
            expect(yield nvim.buffer.name).toMatch('test.js');
        }));
        it('can replace first line of nvim.buffer with a string', () => __awaiter(this, void 0, void 0, function* () {
            nvim.buffer.replace('test', 0);
            expect(yield nvim.buffer.lines).toEqual(['test']);
        }));
        it('can insert lines at beginning of buffer', () => __awaiter(this, void 0, void 0, function* () {
            nvim.buffer.insert(['test', 'foo'], 0);
            expect(yield nvim.buffer.lines).toEqual(['test', 'foo', 'test']);
        }));
        it('can replace nvim.buffer starting at line 1', () => __awaiter(this, void 0, void 0, function* () {
            nvim.buffer.replace(['bar', 'bar', 'bar'], 1);
            expect(yield nvim.buffer.lines).toEqual(['test', 'bar', 'bar', 'bar']);
        }));
        it('inserts line at index 2', () => __awaiter(this, void 0, void 0, function* () {
            nvim.buffer.insert(['foo'], 2);
            expect(yield nvim.buffer.lines).toEqual([
                'test',
                'bar',
                'foo',
                'bar',
                'bar',
            ]);
        }));
        it('removes last 2 lines', () => __awaiter(this, void 0, void 0, function* () {
            nvim.buffer.remove(-3, -1);
            expect(yield nvim.buffer.lines).toEqual(['test', 'bar', 'foo']);
        }));
        it('append lines to end of buffer', () => __awaiter(this, void 0, void 0, function* () {
            nvim.buffer.append(['test', 'test']);
            expect(yield nvim.buffer.lines).toEqual([
                'test',
                'bar',
                'foo',
                'test',
                'test',
            ]);
        }));
        it('can clear the buffer', () => __awaiter(this, void 0, void 0, function* () {
            nvim.buffer.remove(0, -1);
            // One empty line
            expect(yield nvim.buffer.length).toEqual(1);
            expect(yield nvim.buffer.lines).toEqual(['']);
        }));
    });
});
