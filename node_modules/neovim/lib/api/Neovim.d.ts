import { BaseApi } from './Base';
import { Buffer, AsyncBuffer } from './Buffer';
import { Tabpage, AsyncTabpage } from './Tabpage';
import { Window, AsyncWindow } from './Window';
import { VimValue } from '../types/VimValue';
import { ApiInfo } from '../types/ApiInfo';
export declare type UiAttachOptions = {
    rgb?: boolean;
    ext_popupmenu?: boolean;
    ext_tabline?: boolean;
    ext_wildmenu?: boolean;
    ext_cmdline?: boolean;
};
export declare type Proc = {
    ppid: number;
    name: string;
    pid: number;
};
/**
 * Neovim API
 */
export declare class Neovim extends BaseApi {
    protected prefix: string;
    Buffer: typeof Buffer;
    Window: typeof Window;
    Tabpage: typeof Tabpage;
    readonly apiInfo: Promise<[number, ApiInfo]>;
    /** Get list of all buffers */
    readonly buffers: Promise<Buffer[]>;
    /** Get current buffer */
    /** Set current buffer */
    buffer: AsyncBuffer;
    readonly chans: Promise<number[]>;
    getChanInfo(chan: number): Promise<object>;
    readonly commands: Promise<Object>;
    getCommands(options?: {}): Promise<Object>;
    /** Get list of all tabpages */
    readonly tabpages: Promise<Tabpage[]>;
    /** Get current tabpage */
    /** Set current tabpage */
    tabpage: AsyncTabpage;
    /** Get list of all windows */
    readonly windows: Promise<Window[]>;
    /** Get current window */
    /** Set current window */
    window: AsyncWindow;
    /** Get list of all windows */
    getWindows(): Promise<Window[]>;
    /** Get current window */
    getWindow(): AsyncWindow;
    setWindow(win: Window): Promise<any>;
    /** Get list of all runtime paths */
    readonly runtimePaths: Promise<string[]>;
    /** Set current directory */
    dir: string;
    /** Get current line. Always returns a Promise. */
    /** Set current line */
    line: string | Promise<string>;
    getLine(): Promise<string>;
    /** Set current line */
    setLine(line: string): Promise<any>;
    /** Gets keymap */
    getKeymap(mode: string): Promise<Array<object>>;
    /** Gets current mode */
    readonly mode: Promise<{
        mode: string;
        blocking: boolean;
    }>;
    /** Gets map of defined colors */
    readonly colorMap: Promise<{
        [name: string]: number;
    }>;
    /** Get color by name */
    getColorByName(name: string): Promise<number>;
    /** Get highlight by name or id */
    getHighlight(nameOrId: string | number, isRgb?: boolean): Promise<object> | void;
    getHighlightByName(name: string, isRgb?: boolean): Promise<object>;
    getHighlightById(id: number, isRgb?: boolean): Promise<object>;
    /** Delete current line in buffer */
    deleteCurrentLine(): Promise<any>;
    /**
     * Evaluates a VimL expression (:help expression). Dictionaries
     * and Lists are recursively expanded. On VimL error: Returns a
     * generic error; v:errmsg is not updated.
     *
     */
    eval(expr: string): Promise<VimValue>;
    /**
     * Executes lua, it's possible neovim client does not support this
     */
    lua(code: string, args?: Array<VimValue>): Promise<object>;
    executeLua(code: string, args?: Array<VimValue>): Promise<object>;
    callDictFunction(dict: object, fname: string, args?: VimValue | Array<VimValue>): object;
    /** Call a vim function */
    call(fname: string, args?: VimValue | Array<VimValue>): Promise<any>;
    /** Alias for `call` */
    callFunction(fname: string, args?: VimValue | Array<VimValue>): Promise<any>;
    /** Call Atomic calls */
    callAtomic(calls: Array<VimValue>): Promise<[Array<any>, boolean]>;
    /** Runs a vim command */
    command(arg: string): Promise<any>;
    /** Runs a command and returns output (synchronous?) */
    commandOutput(arg: string): Promise<string>;
    /** Gets a v: variable */
    getVvar(name: string): Promise<VimValue>;
    /** feedKeys */
    feedKeys(keys: string, mode: string, escapeCsi: boolean): Promise<any>;
    /** Sends input keys */
    input(keys: string): Promise<number>;
    /**
     * Parse a VimL Expression
     *
     * TODO: return type, see :help
     */
    parseExpression(expr: string, flags: string, highlight: boolean): Promise<object>;
    getProc(pid: number): Promise<Proc>;
    getProcChildren(pid: number): Promise<Proc[]>;
    /** Replace term codes */
    replaceTermcodes(str: string, fromPart: boolean, doIt: boolean, special: boolean): Promise<string>;
    /** Gets width of string */
    strWidth(str: string): Promise<number>;
    /** Write to output buffer */
    outWrite(str: string): Promise<any>;
    outWriteLine(str: string): Promise<any>;
    /** Write to error buffer */
    errWrite(str: string): Promise<any>;
    /** Write to error buffer */
    errWriteLine(str: string): Promise<any>;
    readonly uis: Promise<any[]>;
    uiAttach(width: number, height: number, options: UiAttachOptions): Promise<void>;
    uiDetach(): Promise<void>;
    uiTryResize(width: number, height: number): Promise<void>;
    /** Set UI Option */
    uiSetOption(name: string, value: any): Promise<void>;
    /** Subscribe to nvim event broadcasts */
    subscribe(event: string): Promise<void>;
    /** Unsubscribe to nvim event broadcasts */
    unsubscribe(event: string): Promise<void>;
    setClientInfo(name: string, version: object, type: string, methods: object, attributes: object): void;
    /** Quit nvim */
    quit(): void;
}
