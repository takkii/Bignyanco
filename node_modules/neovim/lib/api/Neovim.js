"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Base_1 = require("./Base");
const createChainableApi_1 = require("./helpers/createChainableApi");
const Buffer_1 = require("./Buffer");
const Tabpage_1 = require("./Tabpage");
const Window_1 = require("./Window");
/**
 * Neovim API
 */
class Neovim extends Base_1.BaseApi {
    constructor() {
        super(...arguments);
        this.prefix = 'nvim_';
        this.Buffer = Buffer_1.Buffer;
        this.Window = Window_1.Window;
        this.Tabpage = Tabpage_1.Tabpage;
    }
    get apiInfo() {
        return this.request(`${this.prefix}get_api_info`);
    }
    /** Get list of all buffers */
    get buffers() {
        return this.request(`${this.prefix}list_bufs`);
    }
    /** Get current buffer */
    get buffer() {
        return createChainableApi_1.createChainableApi.call(this, 'Buffer', Buffer_1.Buffer, () => this.request(`${this.prefix}get_current_buf`));
    }
    /** Set current buffer */
    set buffer(buffer) {
        this.request(`${this.prefix}set_current_buf`, [buffer]);
    }
    get chans() {
        return this.request(`${this.prefix}list_chans`);
    }
    getChanInfo(chan) {
        return this.request(`${this.prefix}get_chan_info`, [chan]);
    }
    get commands() {
        return this.getCommands();
    }
    getCommands(options = {}) {
        return this.request(`${this.prefix}get_commands`, [options]);
    }
    /** Get list of all tabpages */
    get tabpages() {
        return this.request(`${this.prefix}list_tabpages`);
    }
    /** Get current tabpage */
    get tabpage() {
        return createChainableApi_1.createChainableApi.call(this, 'Tabpage', Tabpage_1.Tabpage, () => this.request(`${this.prefix}get_current_tabpage`));
    }
    /** Set current tabpage */
    set tabpage(tabpage) {
        this.request(`${this.prefix}set_current_tabpage`, [tabpage]);
    }
    /** Get list of all windows */
    get windows() {
        return this.getWindows();
    }
    /** Get current window */
    get window() {
        return this.getWindow();
    }
    /** Set current window */
    set window(win) {
        this.setWindow(win);
    }
    /** Get list of all windows */
    getWindows() {
        return this.request(`${this.prefix}list_wins`);
    }
    /** Get current window */
    getWindow() {
        return createChainableApi_1.createChainableApi.call(this, 'Window', Window_1.Window, () => this.request(`${this.prefix}get_current_win`));
    }
    setWindow(win) {
        // Throw error if win is not instance of Window?
        return this.request(`${this.prefix}set_current_win`, [win]);
    }
    /** Get list of all runtime paths */
    get runtimePaths() {
        return this.request(`${this.prefix}list_runtime_paths`);
    }
    /** Set current directory */
    set dir(dir) {
        this.request(`${this.prefix}set_current_dir`, [dir]);
    }
    /** Get current line. Always returns a Promise. */
    get line() {
        return this.getLine();
    }
    /** Set current line */
    set line(line) {
        // Doing this to satisfy TS requirement that get/setters have to be same type
        if (typeof line === 'string') {
            this.setLine(line);
        }
    }
    getLine() {
        return this.request(`${this.prefix}get_current_line`);
    }
    /** Set current line */
    setLine(line) {
        return this.request(`${this.prefix}set_current_line`, [line]);
    }
    /** Gets keymap */
    getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
    }
    /** Gets current mode */
    get mode() {
        return this.request(`${this.prefix}get_mode`);
    }
    /** Gets map of defined colors */
    get colorMap() {
        return this.request(`${this.prefix}get_color_map`);
    }
    /** Get color by name */
    getColorByName(name) {
        return this.request(`${this.prefix}get_color_by_name`, [name]);
    }
    /** Get highlight by name or id */
    getHighlight(nameOrId, isRgb = true) {
        const functionName = typeof nameOrId === 'string' ? 'by_name' : 'by_id';
        return this.request(`${this.prefix}get_hl_${functionName}`, [
            nameOrId,
            isRgb,
        ]);
    }
    getHighlightByName(name, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_name`, [name, isRgb]);
    }
    getHighlightById(id, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_id`, [id, isRgb]);
    }
    /** Delete current line in buffer */
    deleteCurrentLine() {
        return this.request(`${this.prefix}del_current_line`);
    }
    /**
     * Evaluates a VimL expression (:help expression). Dictionaries
     * and Lists are recursively expanded. On VimL error: Returns a
     * generic error; v:errmsg is not updated.
     *
     */
    eval(expr) {
        return this.request(`${this.prefix}eval`, [expr]);
    }
    /**
     * Executes lua, it's possible neovim client does not support this
     */
    lua(code, args = []) {
        const _args = Array.isArray(args) ? args : [args];
        return this.request(`${this.prefix}execute_lua`, [code, _args]);
    }
    // Alias for `lua()` to be consistent with neovim API
    executeLua(code, args = []) {
        return this.lua(code, args);
    }
    callDictFunction(dict, fname, args = []) {
        const _args = Array.isArray(args) ? args : [args];
        return this.request(`${this.prefix}call_dict_function`, [
            dict,
            fname,
            _args,
        ]);
    }
    /** Call a vim function */
    call(fname, args = []) {
        const _args = Array.isArray(args) ? args : [args];
        return this.request(`${this.prefix}call_function`, [fname, _args]);
    }
    /** Alias for `call` */
    callFunction(fname, args = []) {
        return this.call(fname, args);
    }
    /** Call Atomic calls */
    callAtomic(calls) {
        return this.request(`${this.prefix}call_atomic`, [calls]);
    }
    /** Runs a vim command */
    command(arg) {
        return this.request(`${this.prefix}command`, [arg]);
    }
    /** Runs a command and returns output (synchronous?) */
    commandOutput(arg) {
        return this.request(`${this.prefix}command_output`, [arg]);
    }
    /** Gets a v: variable */
    getVvar(name) {
        return this.request(`${this.prefix}get_vvar`, [name]);
    }
    /** feedKeys */
    feedKeys(keys, mode, escapeCsi) {
        return this.request(`${this.prefix}feedkeys`, [keys, mode, escapeCsi]);
    }
    /** Sends input keys */
    input(keys) {
        return this.request(`${this.prefix}input`, [keys]);
    }
    /**
     * Parse a VimL Expression
     *
     * TODO: return type, see :help
     */
    parseExpression(expr, flags, highlight) {
        return this.request(`${this.prefix}parse_expression`, [
            expr,
            flags,
            highlight,
        ]);
    }
    getProc(pid) {
        return this.request(`${this.prefix}get_proc`, [pid]);
    }
    getProcChildren(pid) {
        return this.request(`${this.prefix}get_proc_children`, [pid]);
    }
    /** Replace term codes */
    replaceTermcodes(str, fromPart, doIt, special) {
        return this.request(`${this.prefix}replace_termcodes`, [
            str,
            fromPart,
            doIt,
            special,
        ]);
    }
    /** Gets width of string */
    strWidth(str) {
        return this.request(`${this.prefix}strwidth`, [str]);
    }
    /** Write to output buffer */
    outWrite(str) {
        return this.request(`${this.prefix}out_write`, [str]);
    }
    outWriteLine(str) {
        return this.outWrite(`${str}\n`);
    }
    /** Write to error buffer */
    errWrite(str) {
        return this.request(`${this.prefix}err_write`, [str]);
    }
    /** Write to error buffer */
    errWriteLine(str) {
        return this.request(`${this.prefix}err_writeln`, [str]);
    }
    // TODO: add type
    get uis() {
        return this.request(`${this.prefix}list_uis`);
    }
    uiAttach(width, height, options) {
        return this.request(`${this.prefix}ui_attach`, [width, height, options]);
    }
    uiDetach() {
        return this.request(`${this.prefix}ui_detach`, []);
    }
    uiTryResize(width, height) {
        return this.request(`${this.prefix}ui_try_resize`, [width, height]);
    }
    /** Set UI Option */
    uiSetOption(name, value) {
        return this.request(`${this.prefix}ui_set_option`, [name, value]);
    }
    /** Subscribe to nvim event broadcasts */
    subscribe(event) {
        return this.request(`${this.prefix}subscribe`, [event]);
    }
    /** Unsubscribe to nvim event broadcasts */
    unsubscribe(event) {
        return this.request(`${this.prefix}unsubscribe`, [event]);
    }
    setClientInfo(name, version, type, methods, attributes) {
        this.request(`${this.prefix}set_client_info`, [
            name,
            version,
            type,
            methods,
            attributes,
        ]);
    }
    /** Quit nvim */
    quit() {
        this.command('qa!');
    }
}
exports.Neovim = Neovim;
