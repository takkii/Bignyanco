"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-env jest */
const cp = require("child_process");
const path = require("path");
// eslint-disable-next-line import/no-extraneous-dependencies
const which = require("which");
const attach_1 = require("../attach");
try {
    which.sync('nvim');
}
catch (e) {
    // eslint-disable-next-line no-console
    console.error('A Neovim installation is required to run the tests', '(see https://github.com/neovim/neovim/wiki/Installing)');
    process.exit(1);
}
describe('Neovim API', () => {
    let proc;
    let nvim;
    beforeAll((done) => __awaiter(this, void 0, void 0, function* () {
        proc = cp.spawn('nvim', ['-u', 'NONE', '-N', '--embed', '-c', 'set noswapfile', 'test.js'], {
            cwd: __dirname,
        });
        nvim = yield attach_1.attach({ proc });
        done();
    }));
    afterAll(() => {
        nvim.quit();
        if (proc) {
            proc.disconnect();
        }
    });
    beforeEach(() => { });
    describe('Normal API calls', () => {
        it('gets a list of buffers and switches buffers', () => __awaiter(this, void 0, void 0, function* () {
            const buffers = yield nvim.buffers;
            expect(buffers.length).toBe(1);
            const initialBufferName = yield buffers[0].name;
            nvim.command('e test2.js');
            expect((yield nvim.buffers).length).toBe(2);
            expect(yield nvim.buffer.name).toEqual(initialBufferName.replace('test', 'test2'));
            // switch buffers
            nvim.buffer = buffers[0];
            expect(yield nvim.buffer.name).toEqual(initialBufferName);
        }));
        it('can list runtimepaths', () => __awaiter(this, void 0, void 0, function* () {
            expect((yield nvim.runtimePaths).length).toBeGreaterThan(0);
        }));
        it('can change current working directory', () => __awaiter(this, void 0, void 0, function* () {
            const initial = yield nvim.call('getcwd', []);
            const newCwd = path.dirname(initial);
            nvim.dir = newCwd;
            expect(yield nvim.call('getcwd', [])).toBe(newCwd);
        }));
        it.skip('can get current mode', () => __awaiter(this, void 0, void 0, function* () {
            const initial = yield nvim.mode;
            expect(initial).toEqual({ mode: 'n', blocking: false });
            yield nvim.command('startinsert');
        }));
        it('can get color map', () => __awaiter(this, void 0, void 0, function* () {
            const colorMap = yield nvim.colorMap;
            expect(Object.keys(colorMap).length).toBeGreaterThan(0);
        }));
        it('can get color by name', () => __awaiter(this, void 0, void 0, function* () {
            expect(yield nvim.getColorByName('white')).toBe(16777215);
        }));
        it('can get highlight by name or id', () => __awaiter(this, void 0, void 0, function* () { }));
        it('can run lua', () => __awaiter(this, void 0, void 0, function* () {
            expect(yield nvim.lua('function test(a) return a end return test(...)', 1)).toBe(1);
            expect(yield nvim.lua('function test(a) return a end return test(...)', [
                'foo',
            ])).toBe('foo');
        }));
        it('get/set/delete current line', () => __awaiter(this, void 0, void 0, function* () {
            const line = yield nvim.line;
            expect(line).toBe('');
            nvim.line = 'current line';
            expect(yield nvim.line).toBe('current line');
            nvim.deleteCurrentLine();
            expect(yield nvim.line).toBe('');
        }));
        it('gets v: vars', () => __awaiter(this, void 0, void 0, function* () {
            const initial = yield nvim.eval('v:ctype');
            expect(yield nvim.getVvar('ctype')).toBe(initial);
        }));
        it('gets string width', () => __awaiter(this, void 0, void 0, function* () {
            expect(yield nvim.strWidth('string')).toBe(6);
        }));
        it('write to vim output buffer', () => __awaiter(this, void 0, void 0, function* () {
            // TODO how to test this?
            nvim.outWrite('test');
        }));
        it('write to vim error buffer', () => __awaiter(this, void 0, void 0, function* () {
            // TODO how to test this?
            nvim.errWrite('test');
            nvim.errWriteLine('test');
        }));
    });
    describe.skip('Chainable API calls', () => { });
});
