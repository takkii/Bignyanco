"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-env jest */
const path = require("path");
const factory_1 = require("./factory");
const PLUGIN_PATH = path.join(__dirname, '..', '..', '__tests__', 'integration', 'rplugin', 'node');
describe('Plugin Factory (used by host)', () => {
    let pluginObj;
    beforeEach(() => {
        pluginObj = factory_1.loadPlugin(path.join(PLUGIN_PATH, 'test'), null);
    });
    it('should collect the specs from a plugin file', () => {
        const expected = [
            {
                type: 'autocmd',
                name: 'BufEnter',
                sync: true,
                opts: { pattern: '*.test', eval: 'expand("<afile>")' },
            },
            {
                type: 'command',
                name: 'JSHostTestCmd',
                sync: true,
                opts: { range: '', nargs: '*' },
            },
            { type: 'function', name: 'Func', sync: true, opts: {} },
            { type: 'function', name: 'Global', sync: true, opts: {} },
        ];
        expect(pluginObj.specs).toEqual(expected);
    });
    it('should collect the handlers from a plugin', () => __awaiter(this, void 0, void 0, function* () {
        expect(yield pluginObj.handleRequest('Func', 'function', ['town'])).toEqual('Funcy town');
    }));
    it('should load the plugin a sandbox', () => __awaiter(this, void 0, void 0, function* () {
        expect(yield pluginObj.handleRequest('Global', 'function', ['loaded'])).toEqual(true);
        expect(yield pluginObj.handleRequest('Global', 'function', ['process'])).not.toContain(['chdir', 'exit']);
    }));
    it('should load files required by the plugin in a sandbox', () => __awaiter(this, void 0, void 0, function* () {
        expect(yield pluginObj.handleRequest('Global', 'function', ['required'])).toEqual('you bet!');
        // expect(
        // Object.keys(required.globals.process),
        // ).not.toContain(
        // ['chdir', 'exit'],
        // );
    }));
    it('loads plugin with instance of nvim API', () => {
        const nvim = {};
        const plugin = factory_1.loadPlugin(path.join(PLUGIN_PATH, 'test'), nvim, {});
        expect(plugin.nvim).toBe(nvim);
    });
    it('returns null on invalid module', () => {
        expect(factory_1.loadPlugin('/asdlfjka/fl', {}, {})).toBeNull();
    });
});
describe('Plugin Factory (decorator api)', () => {
    let pluginObj;
    beforeEach(() => {
        pluginObj = factory_1.loadPlugin(path.join(PLUGIN_PATH, 'test_2'), null);
    });
    it('should collect the specs from a plugin file', () => {
        const expected = [
            {
                type: 'autocmd',
                name: 'BufEnter',
                sync: true,
                opts: { pattern: '*.test', eval: 'expand("<afile>")' },
            },
            {
                type: 'command',
                name: 'JSHostTestCmd',
                sync: true,
                opts: { range: '', nargs: '*' },
            },
            { type: 'function', name: 'Func', sync: true, opts: {} },
            { type: 'function', name: 'Global', sync: true, opts: {} },
            { type: 'function', name: 'Illegal', sync: true, opts: {} },
        ];
        expect(pluginObj.specs).toEqual(expect.arrayContaining(expected));
    });
    it('should collect the handlers from a plugin', () => __awaiter(this, void 0, void 0, function* () {
        expect(yield pluginObj.handleRequest('Func', 'function', ['town'])).toEqual('Funcy town');
    }));
    it('should load the plugin a sandbox', () => __awaiter(this, void 0, void 0, function* () {
        expect(yield pluginObj.handleRequest('Global', 'function', ['loaded'])).toEqual(true);
        expect(yield pluginObj.handleRequest('Global', 'function', ['process'])).not.toContain(['chdir', 'exit']);
    }));
    it('should load files required by the plugin in a sandbox', () => __awaiter(this, void 0, void 0, function* () {
        expect(yield pluginObj.handleRequest('Global', 'function', ['required'])).toEqual('you bet!');
        // expect(
        // Object.keys(required.globals.process),
        // ).not.toContain(
        // ['chdir', 'exit'],
        // );
    }));
    it('loads plugin with instance of nvim API', () => {
        const nvim = {};
        const plugin = factory_1.loadPlugin(path.join(PLUGIN_PATH, 'test_2'), nvim, {});
        expect(plugin.nvim).toBe(nvim);
    });
    it('cannot call illegal process functions', () => {
        const nvim = {};
        const plugin = factory_1.loadPlugin(path.join(PLUGIN_PATH, 'test_2'), nvim, {});
        expect(plugin.functions.Illegal.fn).toThrow();
    });
    it('cannot write to process.umask', () => {
        const nvim = {};
        const plugin = factory_1.loadPlugin(path.join(PLUGIN_PATH, 'test_2'), nvim, {});
        expect(() => plugin.functions.Umask.fn(123)).toThrow();
    });
    it('can read process.umask()', () => {
        const nvim = {};
        const plugin = factory_1.loadPlugin(path.join(PLUGIN_PATH, 'test_2'), nvim, {});
        expect(() => plugin.functions.Umask.fn()).not.toThrow();
        expect(plugin.functions.Umask.fn()).toBeDefined();
    });
});
