"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-env jest */
const plugin_1 = require("./plugin");
const NvimPlugin_1 = require("../host/NvimPlugin");
const function_1 = require("./function");
const command_1 = require("./command");
const autocmd_1 = require("./autocmd");
const instantiateOrRun = (Fn, ...args) => {
    try {
        return new Fn(...args);
    }
    catch (err) {
        if (err instanceof TypeError) {
            return Fn(...args);
        }
        throw err;
    }
};
describe('Plugin class decorator', () => {
    it('decorates class with no options', () => {
        class MyClass {
        }
        const plugin = plugin_1.plugin(MyClass);
        expect(typeof plugin).toEqual('function');
    });
    it('decorates class with dev mode option', () => {
        class MyClass {
        }
        const plugin = plugin_1.plugin({ dev: true })(MyClass);
        expect(typeof plugin).toEqual('function');
        const pluginObject = { setOptions: jest.fn() };
        instantiateOrRun(plugin, pluginObject);
        expect(pluginObject.setOptions).toHaveBeenCalledWith({ dev: true });
    });
    it('decorates class methods', () => {
        class MyClass {
        }
        MyClass.prototype.testF = () => { };
        MyClass.prototype.testC = () => { };
        MyClass.prototype.testA = () => { };
        // This is how (closeish) babel applies decorators
        function_1.nvimFunction('TestF', { eval: 'test', range: 'test' })(MyClass.prototype, 'testF');
        command_1.command('TestCommand', { range: 'test', nargs: '3' })(MyClass.prototype, 'testC');
        autocmd_1.autocmd('TestAutocmd', {
            pattern: '*.js',
            eval: 'test',
        })(MyClass.prototype, 'testA');
        const plugin = plugin_1.plugin(MyClass);
        const pluginObject = {
            registerAutocmd: jest.fn(),
            registerCommand: jest.fn(),
            registerFunction: jest.fn(),
        };
        const instance = instantiateOrRun(plugin, pluginObject);
        expect(pluginObject.registerAutocmd).toHaveBeenCalledWith('TestAutocmd', [instance, MyClass.prototype.testA], {
            pattern: '*.js',
            sync: false,
            eval: 'test',
        });
        expect(pluginObject.registerCommand).toHaveBeenCalledWith('TestCommand', [instance, MyClass.prototype.testC], { sync: false, range: 'test', nargs: '3' });
        expect(pluginObject.registerFunction).toHaveBeenCalledWith('TestF', [instance, MyClass.prototype.testF], { sync: false, eval: 'test', range: 'test' });
    });
    it('generates specs from decorated methods', () => {
        class MyClass {
        }
        MyClass.prototype.testF = () => { };
        MyClass.prototype.testC = () => { };
        MyClass.prototype.testA = () => { };
        // This is how (closeish) babel applies decorators
        function_1.nvimFunction('TestF')(MyClass.prototype, 'testF');
        command_1.command('TestCommand')(MyClass.prototype, 'testC');
        autocmd_1.autocmd('TestAutocmd', {
            pattern: '*.js',
        })(MyClass.prototype, 'testA');
        const plugin = plugin_1.plugin(MyClass);
        const pluginObject = new NvimPlugin_1.NvimPlugin('/tmp/filename', plugin, {});
        expect(pluginObject.specs).toEqual([
            {
                type: 'autocmd',
                name: 'TestAutocmd',
                sync: false,
                opts: {
                    pattern: '*.js',
                },
            },
            {
                type: 'command',
                name: 'TestCommand',
                sync: false,
                opts: {},
            },
            {
                type: 'function',
                name: 'TestF',
                sync: false,
                opts: {},
            },
        ]);
    });
});
